//--------------------------------------------------------------------------------------------
// ROMulator 3 - Initialised with data to be sent to the RAM

// Compiled using Arduino 1.65 or later

// A customised vesrion of SIMPL to allow RAM and Z80 bus to be exercised using SIMPL.

// Address is sent using a pair of 74HC595 shift registers
// Data is passed through a 74HC245 bi-directional buffer
// TRISTATE line when raised isolates the address and data registers from the Z80 bus - allowing it to run
// RESET - active low is used to put the Z80 into RESET so that the RAM can be loaded

// Other active low  bus control lines are READ, WRITE, MREQ (/CS) and IORQ


//  Basic memory r/w Commands are as follows  - values are integer decimal

//  170 55w      write the value of 170 to address 55
//  44 32760w    write the value 44 to the RAM address 32760

//  55r          read and print the value stored at address 55
//  132n         output 132 on the ROmulator data port
//  240q         output an 8 bit address 240 on the lower address lines (for I/O operations)

// -------------------------------------------------------------------------------------------
  #include <avr/pgmspace.h>
  #define bufRead(addr)      (*(unsigned char *)(addr))
  #define bufWrite(addr, b)   (*(unsigned char *)(addr) = (b))

   unsigned char bite;
   unsigned int x = 0;
   unsigned int y = 0;
   int len = 48;
   
   
   // Define the I?O pins to be used with the shift registers
   
   int sinPin = 5;      // Serial input pin from 74HC165
   int sclkPin = 6;     // Clock pin to 74HC165
   int loadPin = 7;     // parallel load pin of 74HC165   
   int latchPin = 8;    //Pin connected to ST_CP of 74HC595  - white
   int dataPin = 12;    //Pin connected to DS of 74HC595 - green
   int clockPin = 11;   //Pin connected to SH_CP of 74HC595  - blue


// Z80 Bus Control lines - all active low Digital Outputs

   int MREQ=14;
   int READ = 15;
   int WRITE = 16;
   int TRISTATE = 17;
   int IORQ = 18;
   int RESET = 19;


   
  
   char array[26][48] = {                                  // Define a 26 x 64 array for the colon definitions
                         {"6d75{1o708u0o708u}"},
                         {"9rP8rP12rP4rP6rP2rP3rP1rP"},    // A backward step on a stepper motor
                         {"6d91{1o585u0o585u}"},
                         {"6d100{1o532u0o532u}"},
                         {"6d110{1o484u0o484u}"},
                         {"1rP3rP2rP6rP4rP12rP8rP9rP"},    // A forward step on a stepper motor
                         {"6d133{1o484u0o484u}"},
                         {"_Hello World, and welcome to SIMPL_"},
                         {"5{ABC}"},
                         {" "},
                         {" "},
                         {" "},
                         {" "},
                         {" "},
                         {" "},
                         {"100m"},    // Time delay to see stepper motor action
                         
                         };


    const PROGMEM  char ROM_code[]  = {0x6,0x0,0x10,0xfe,0x3e,0x90,0xd3,0x3,0x3e,0xc0,0xd3,0x2,0x31,0xaf,0x1f,0x3a,
0xe5,0x1f,0xfe,0xa5,0xc4,0xc1,0x3,0x21,0x0,0x10,0xcd,0xf6,0x5,0x28,0x2,0x26,
0x18,0x22,0xdc,0x1f,0x26,0x0,0x18,0x0a,0xe3,0x2b,0xe3,0x22,0xe8,0x1f,0x18,0x0e,
0x18,0x34,0x22,0xd2,0x1f,0x18,0x1d,0x71,0xe5,0x2a,0xee,0x1f,0xe3,0xc9,0x32,0xe7,
0x1f,0x2a,0xe0,0x1f,0x3a,0xe2,0x1f,0x77,0x3e,0x80,0xd3,0x2,0x3a,0xe7,0x1f,0x2a,
0xe8,0x1f,0x0,0xc9,0x21,0x9f,0x1f,0x22,0xd0,0x1f,0xaf,0x32,0xe6,0x1f,0xdd,0x21,
0x9f,0x7,0xc3,0xd0,0x0,0xff,0x32,0xe7,0x1f,0x3e,0x90,0xd3,0x3,0x3e,0xc0,0xd3,
0x2,0x3a,0xe7,0x1f,0x22,0xe8,0x1f,0xe1,0x22,0xde,0x1f,0x22,0xdc,0x1f,0x2a,0xe8,
0x1f,0xed,0x73,0xd0,0x1f,0x31,0xd0,0x1f,0xfd,0xe5,0xdd,0xe5,0xd9,0xe5,0xd5,0xc5,
0xd9,0x8,0xf5,0x8,0xe5,0xd5,0xc5,0xf5,0xed,0x57,0x32,0xd3,0x1f,0x3e,0x0,0xe2,
0xa4,0x0,0x3e,0x1,0x32,0xd2,0x1f,0x31,0xaf,0x1f,0x2a,0xd0,0x1f,0xdd,0x21,0xb5,
0x7,0x2b,0xcd,0xf6,0x5,0x20,0x19,0x2b,0xcd,0xf6,0x5,0x20,0x13,0xdd,0x21,0xaf,
0x7,0x0,0x0,0x11,0x62,0xe0,0x19,0x38,0x7,0xdd,0x21,0xb6,0x1f,0x37,0x18,0x4,
0xaf,0x32,0xe4,0x1f,0x3a,0xe2,0x1f,0x2a,0xe0,0x1f,0x77,0xdc,0x0b,0x4,0x31,0xaf,
0x1f,0xcd,0xfe,0x5,0xcd,0xcb,0x6,0x18,0xf5,0xfe,0x10,0x38,0x24,0x21,0xe6,0x1f,
0xcb,0xc6,0xd6,0x10,0xfe,0x8,0x21,0x37,0x7,0xda,0xb0,0x3,0xdd,0x21,0xb6,0x1f,
0xd6,0x8,0x21,0xe4,0x1f,0x77,0x21,0xe3,0x1f,0x36,0x0,0x21,0x41,0x7,0xc3,0xb0,
0x3,0x4f,0x21,0x4b,0x7,0x3a,0xe4,0x1f,0xc3,0xb0,0x3,0x21,0x57,0x7,0x18,0xf5,
0x21,0x63,0x7,0x18,0xf0,0x21,0x6f,0x7,0x18,0xeb,0xcd,0xe5,0x3,0xc2,0xbb,0x3,
0x3e,0x80,0xc3,0xa3,0x2,0xcd,0xe5,0x3,0x20,0x4,0xcd,0x0b,0x4,0xc9,0xfe,0x8,
0xda,0xbb,0x3,0xcd,0x77,0x4,0xc9,0xcd,0xe5,0x3,0xc2,0xbb,0x3,0x2a,0xde,0x1f,
0xcd,0xf6,0x5,0xc2,0xbb,0x3,0x22,0xe0,0x1f,0xcd,0x0b,0x4,0xc9,0xcd,0xe5,0x3,
0xc2,0xbb,0x3,0x2a,0xde,0x1f,0x0,0x22,0xaf,0x1f,0x23,0x22,0xb3,0x1f,0xcd,0xf6,
0x5,0xc2,0xbb,0x3,0x11,0xfe,0x1d,0x7c,0xfe,0x1e,0x38,0x7,0xfe,0x20,0xda,0xbb,
0x3,0x16,0x27,0xed,0x53,0xb1,0x1f,0xcd,0xe4,0x2,0xaf,0x12,0x2a,0xb3,0x1f,0x22,
0xde,0x1f,0xcd,0x0b,0x4,0xc9,0xcd,0xe5,0x3,0xc2,0xbb,0x3,0x2a,0xde,0x1f,0x0,
0x22,0xb3,0x1f,0xcd,0xf6,0x5,0xc2,0xbb,0x3,0x11,0x0,0x1e,0x7c,0xfe,0x1e,0x38,
0x7,0xfe,0x20,0xda,0xbb,0x3,0x16,0x28,0xed,0x53,0xb1,0x1f,0x23,0x22,0xaf,0x1f,
0x18,0xc5,0x2a,0xdc,0x1f,0x22,0xde,0x1f,0xcd,0x0b,0x4,0xc9,0xcd,0xde,0x3,0x22,
0xde,0x1f,0xcd,0x0b,0x4,0xc9,0xdd,0x21,0xca,0x7,0xcd,0xc4,0x4,0xc9,0xcd,0x2,
0x4,0xc9,0x2a,0xde,0x1f,0x22,0xaf,0x1f,0xcd,0x3a,0x4,0xc9,0xc3,0xbb,0x3,0x2a,
0xde,0x1f,0xcd,0xf6,0x5,0xc2,0xbb,0x3,0xcd,0xee,0x3,0x79,0xed,0x6f,0xcd,0x0b,
0x4,0xc9,0x21,0xde,0x1f,0xcd,0xfa,0x3,0x79,0xed,0x6f,0x23,0xed,0x6f,0xcd,0x2,
0x4,0xc9,0x79,0xdd,0x21,0xb6,0x1f,0x21,0xe3,0x1f,0x87,0x77,0xcd,0x73,0x4,0xc9,
0xcd,0x55,0x4,0xcd,0xfa,0x3,0x79,0xed,0x6f,0x23,0xed,0x6f,0xcd,0x3a,0x4,0xc9,
0xcd,0xbb,0x4,0xcd,0xee,0x3,0x79,0xed,0x6f,0xcd,0x77,0x4,0xc9,0xc3,0xbb,0x3,
0x2a,0xde,0x1f,0x23,0x22,0xde,0x1f,0xcd,0x0b,0x4,0xc9,0x21,0xe3,0x1f,0x34,0xcd,
0x5f,0x4,0x20,0x4,0x35,0xc3,0xbb,0x3,0xcd,0x3a,0x4,0xc9,0x21,0xe3,0x1f,0x34,
0x3e,0x1f,0xbe,0x30,0x2,0x36,0x0,0xcd,0x77,0x4,0xc9,0xc3,0xbb,0x3,0x2a,0xde,
0x1f,0x2b,0x22,0xde,0x1f,0xcd,0x0b,0x4,0xc9,0x21,0xe3,0x1f,0x35,0xcd,0x5f,0x4,
0x20,0x4,0x34,0xc3,0xbb,0x3,0xcd,0x3a,0x4,0xc9,0x21,0xe3,0x1f,0x35,0x3e,0x1f,
0xbe,0x30,0x2,0x36,0x1f,0xcd,0x77,0x4,0xc9,0xc3,0xbb,0x3,0x2a,0xe0,0x1f,0x36,
0xef,0x3e,0xff,0x32,0xea,0x1f,0x3a,0xd2,0x1f,0xcb,0x47,0x21,0xfb,0xc9,0x20,0x2,
0x2e,0xf3,0x22,0xeb,0x1f,0x31,0xbc,0x1f,0xf1,0xc1,0xd1,0xe1,0x8,0xf1,0x8,0xd9,
0xc1,0xd1,0xe1,0xd9,0xdd,0xe1,0xfd,0xe1,0xed,0x7b,0xd0,0x1f,0x32,0xbd,0x1f,0x3a,
0xd3,0x1f,0xed,0x47,0xe5,0x2a,0xde,0x1f,0xe3,0x3a,0xea,0x1f,0xd3,0x2,0x3a,0xbd,
0x1f,0xc3,0xeb,0x1f,0x21,0xaf,0x1f,0xcd,0x3d,0x5,0x38,0x67,0xed,0x5b,0xb3,0x1f,
0xed,0x52,0x30,0x0c,0xeb,0x9,0x2b,0xeb,0x2a,0xb1,0x1f,0xed,0xb8,0x13,0x18,0x1c,
0x19,0xed,0xb0,0x1b,0x18,0x16,0xed,0x5b,0xaf,0x1f,0x13,0x13,0x2a,0xb1,0x1f,0xb7,
0xed,0x52,0x7d,0x17,0x7c,0xce,0x0,0x20,0x3a,0x7d,0x1b,0x12,0xed,0x53,0xde,0x1f,
0xcd,0x0b,0x4,0xc9,0xcd,0x2d,0x5,0x38,0x2a,0x32,0xb5,0x1f,0x21,0xa0,0x0f,0xcd,
0xde,0x5,0x21,0xaf,0x1f,0x1,0x7,0x0,0xcd,0xa7,0x5,0x21,0xa0,0x0f,0xcd,0xe2,
0x5,0xcd,0x3a,0x5,0xcd,0xa7,0x5,0x21,0xa0,0x0f,0xcd,0xe2,0x5,0xed,0x5b,0xb3,
0x1f,0x18,0xc9,0xdd,0x21,0xa9,0x7,0xc3,0xd0,0x0,0x2a,0xaf,0x1f,0x22,0xea,0x1f,
0x3e,0x40,0xd3,0x1,0x21,0xe8,0x3,0xcd,0x8c,0x5,0x38,0xf4,0x2b,0x7c,0xb5,0x20,
0xf6,0xcd,0x8c,0x5,0x30,0xfb,0x21,0xaf,0x1f,0x1,0x7,0x0,0xcd,0x4d,0x5,0x38,
0xdf,0xed,0x5b,0xaf,0x1f,0xcd,0x65,0x6,0x6,0x96,0xcd,0x24,0x6,0x10,0xfb,0x2a,
0xea,0x1f,0xb7,0xed,0x52,0x20,0xc9,0x3e,0x2,0xd3,0x1,0xcd,0x3a,0x5,0x38,0xb3,
0xcd,0x4d,0x5,0x38,0xae,0xcd,0x2d,0x5,0x21,0xb5,0x1f,0xbe,0x20,0xa5,0x18,0x9d,
0x5e,0x23,0x56,0x23,0x85,0x6f,0x6e,0x26,0x0,0x19,0xe9,0x21,0xe6,0x1f,0xcb,0xfe,
0xc9,0xdd,0x21,0xa5,0x7,0x0e,0x7,0x6,0x10,0xcd,0x24,0x6,0x10,0xfb,0xdd,0x2b,
0x0d,0x20,0xf4,0x3e,0xa5,0xc3,0xb3,0x6,0x21,0x66,0x0,0x22,0xee,0x1f,0x21,0xff,
0xff,0x22,0xe0,0x1f,0xc9,0x3a,0xe4,0x1f,0xfe,0x1,0xc8,0xfe,0x2,0xc9,0x3a,0xe6,
0x1f,0xb7,0xc8,0x3e,0x0,0x77,0x32,0xe6,0x1f,0xc9,0xcd,0xee,0x3,0xc8,0x23,0x77,
0x2b,0xc9,0x3e,0x1,0x6,0x4,0x21,0xb8,0x1f,0x18,0x7,0x3e,0x2,0x6,0x2,0x21,
0xb6,0x1f,0x32,0xe4,0x1f,0xd9,0xed,0x5b,0xde,0x1f,0xcd,0x65,0x6,0x1a,0xcd,0x71,
0x6,0x2a,0xe0,0x1f,0x7e,0x32,0xe2,0x1f,0xb7,0xed,0x52,0x20,0x6,0x6,0x6,0x21,
0xb6,0x1f,0xd9,0xd9,0xcb,0xf6,0x23,0x10,0xfb,0xc9,0xcd,0x55,0x4,0x5e,0x23,0x56,
0xcd,0x65,0x6,0x21,0xb8,0x1f,0x6,0x4,0xcd,0x34,0x4,0xcd,0x5f,0x4,0x6f,0x26,
0x2,0x22,0xb6,0x1f,0xc9,0x3a,0xe3,0x1f,0x87,0x21,0xaf,0x1f,0x85,0x6f,0xc9,0x3a,
0xe4,0x1f,0xd6,0x4,0x87,0x87,0x11,0xbc,0x7,0x83,0x5f,0x3a,0xe3,0x1f,0x83,0x5f,
0x1a,0xb7,0xc9,0x3e,0x8,0x18,0x2,0x3e,0x9,0x32,0xe4,0x1f,0x3a,0xe3,0x1f,0xcb,
0x87,0x47,0xcd,0xae,0x4,0x78,0xcd,0xbe,0x4,0x5e,0x23,0x56,0xed,0x53,0xde,0x1f,
0xcd,0x65,0x6,0x3a,0xe4,0x1f,0xfe,0x9,0xc0,0x21,0xb8,0x1f,0x3a,0xe3,0x1f,0xcb,
0x47,0x28,0x2,0x23,0x23,0xcb,0xf6,0x23,0xcb,0xf6,0xcd,0xc4,0x4,0xc9,0x21,0xd0,
0x7,0x85,0x6f,0x5e,0x23,0x56,0xed,0x53,0xb6,0x1f,0xc9,0x3a,0xe3,0x1f,0x21,0xbc,
0x1f,0x85,0x6f,0xc9,0x3a,0xe3,0x1f,0xb7,0x1f,0xfe,0x0b,0x28,0x9,0x4f,0x21,0xd2,
0x1f,0x7e,0xe6,0x1,0x77,0x79,0xfe,0x0c,0x30,0x1f,0x3a,0xbc,0x1f,0xcd,0x18,0x5,
0x22,0xd4,0x1f,0xcd,0x18,0x5,0x22,0xd6,0x1f,0x3a,0xc4,0x1f,0xcd,0x18,0x5,0x22,
0xd8,0x1f,0xcd,0x18,0x5,0x22,0xda,0x1f,0xc9,0x2a,0xd4,0x1f,0xcd,0x23,0x5,0x2a,
0xd6,0x1f,0xcd,0x23,0x5,0x32,0xbc,0x1f,0x2a,0xd8,0x1f,0xcd,0x23,0x5,0x2a,0xda,
0x1f,0xcd,0x23,0x5,0x32,0xc4,0x1f,0xc9,0x6,0x4,0x29,0x29,0x29,0x7,0xed,0x6a,
0x10,0xf8,0xc9,0x6,0x4,0x29,0x29,0x29,0x29,0x17,0x10,0xf9,0xc9,0xcd,0x3a,0x5,
0xd8,0xaf,0x86,0xed,0xa1,0xea,0x32,0x5,0xb7,0xc9,0x21,0xb1,0x1f,0x5e,0x23,0x56,
0x23,0x4e,0x23,0x66,0x69,0xb7,0xed,0x52,0x4d,0x44,0x3,0xeb,0xc9,0xaf,0x8,0xcd,
0x5a,0x5,0x73,0xed,0xa1,0xea,0x4f,0x5,0x8,0xc9,0xcd,0x6b,0x5,0x16,0x8,0xcd,
0x6b,0x5,0xcb,0x1b,0x15,0x20,0xf8,0xcd,0x6b,0x5,0xc9,0xd9,0x21,0x0,0x0,0xcd,
0x8c,0x5,0x14,0x15,0x20,0x11,0x38,0x6,0x2d,0x2d,0xcb,0xc4,0x18,0xf1,0x2c,0xcb,
0x44,0x28,0xec,0xcb,0x15,0xd9,0xc9,0x8,0x37,0x8,0xd9,0xc9,0x11,0x0,0x0,0xdb,
0x0,0x13,0x17,0x38,0xfa,0x3e,0xff,0xd3,0x2,0xdb,0x0,0x13,0x17,0x30,0xfa,0x3e,
0x7f,0xd3,0x2,0x7b,0xfe,0x2a,0xc9,0x5e,0xcd,0xb1,0x5,0xed,0xa1,0xea,0xa7,0x5,
0xc9,0x16,0x8,0xb7,0xcd,0xc4,0x5,0xcb,0x1b,0xcd,0xc4,0x5,0x15,0x20,0xf8,0x37,
0xcd,0xc4,0x5,0xc9,0xd9,0x26,0x0,0x38,0x9,0x2e,0x8,0xcd,0xe2,0x5,0x2e,0x2,
0x18,0x7,0x2e,0x4,0xcd,0xe2,0x5,0x2e,0x4,0xcd,0xde,0x5,0xd9,0xc9,0x0e,0x41,
0x18,0x2,0x0e,0x1f,0x29,0x11,0x1,0x0,0x3e,0xff,0xd3,0x2,0x41,0x10,0xfe,0xee,
0x80,0xed,0x52,0x20,0xf5,0xc9,0x7e,0x2f,0x77,0x7e,0x2f,0x77,0xbe,0xc9,0xdd,0xe5,
0x21,0xe6,0x1f,0xcb,0x7e,0x28,0x4,0xdd,0x21,0xa5,0x7,0x6,0x4,0xcd,0x24,0x6,
0x30,0xf9,0x10,0xf9,0xcb,0xbe,0xdd,0xe1,0xcd,0x24,0x6,0x38,0xfb,0x21,0x7b,0x7,
0x85,0x6f,0x7e,0xc9,0x37,0x8,0xd9,0x0e,0x0,0x1e,0xc1,0x26,0x6,0x7b,0xd3,0x2,
0xdd,0x7e,0x0,0xd3,0x1,0x6,0xc9,0x10,0xfe,0xaf,0xd3,0x1,0x7b,0x2f,0xf6,0xc0,
0xd3,0x2,0x6,0x6,0xdb,0x0,0x57,0xcb,0x1a,0x38,0x2,0x79,0x8,0x0c,0x10,0xf7,
0xdd,0x23,0x7b,0xe6,0x3f,0xcb,0x7,0xf6,0xc0,0x5f,0x25,0x20,0xd0,0x11,0xfa,0xff,
0xdd,0x19,0xd9,0x8,0xc9,0x21,0xb8,0x1f,0x7b,0xcd,0x78,0x6,0x7a,0xcd,0x78,0x6,
0xc9,0x21,0xb6,0x1f,0xcd,0x78,0x6,0xc9,0xf5,0xcd,0x89,0x6,0x77,0x23,0xf1,0x0f,
0x0f,0x0f,0x0f,0xcd,0x89,0x6,0x77,0x23,0xc9,0xe5,0x21,0xf0,0x7,0xe6,0x0f,0x85,
0x6f,0x7e,0xe1,0xc9,0x21,0x0,0x18,0x1,0x0,0x8,0xcd,0xf6,0x5,0x28,0x1,0x76,
0xed,0xa1,0xea,0x9a,0x6,0xc7,0x21,0x0,0x0,0x1,0x0,0x8,0xcd,0x31,0x5,0x28,
0x1,0x76,0xc7,0x32,0xe5,0x1f,0x3e,0x55,0x32,0xf0,0x1f,0x3e,0x44,0x32,0xf1,0x1f,
0x21,0xf2,0x1f,0x36,0x2f,0x23,0x36,0x0,0xc3,0xd8,0x3,0xf5,0x21,0xf1,0x1f,0x4e,
0x2a,0xf2,0x1f,0x3a,0xf0,0x1f,0xfe,0x55,0x20,0x3,0xcd,0xe4,0x5,0xf1,0xc3,0xe9,
0x0,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x1b,0x1,0x0,0x5,0x0a,0x0f,0x1a,0x2c,0x42,
0x7b,0xc2,0x1,0x0,0x1c,0x0a,0x14,0x20,0x20,0x26,0x26,0xec,0x1,0x0,0x16,0x3,
0x26,0x34,0x34,0x34,0x34,0x26,0x44,0x3d,0x2,0x0,0x3,0x3,0x0,0x0e,0x0e,0x0e,
0x0e,0x1f,0x1f,0x6b,0x2,0x0,0x3,0x3,0x0,0x0e,0x0e,0x0e,0x0e,0x1f,0x1f,0x99,
0x2,0x0,0x3,0x3,0x0,0x4b,0x6d,0x8b,0xc1,0x0,0x0,0x3,0x7,0x0b,0x0f,0x20,
0x21,0x2,0x6,0x0a,0x0e,0x22,0x23,0x1,0x5,0x9,0x0d,0x13,0x1f,0x0,0x4,0x8,
0x0c,0x12,0x1e,0x1a,0x18,0x1b,0x19,0x17,0x1d,0x15,0x11,0x14,0x10,0x16,0x1c,0x30,
0x2,0x2,0x0f,0x1f,0xa1,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x3,0x8f,0x2,0x1f,
0xae,0x2,0xae,0xb6,0xae,0x1f,0xae,0x2,0x3,0x3,0x8f,0x0,0xae,0x8f,0xb3,0x0,
0xae,0xb3,0x0,0x0,0x0f,0xae,0x8f,0x0,0x0f,0x0,0x0,0x0,0x2,0xbe,0x8f,0x3,
0x0f,0x3f,0x8d,0xa7,0x8f,0xb3,0x85,0x37,0x4f,0x3f,0xcd,0xa7,0xcf,0xb3,0xc5,0x37,
0x7,0x30,0xb6,0x30,0x1f,0xae,0x0f,0x30,0x37,0x0f,0x85,0x0f,0x77,0x0f,0xc5,0x0f,
0xbd,0x30,0x9b,0xba,0x36,0xae,0xaf,0x38,0xbf,0xbe,0x3f,0xa7,0x8d,0xb3,0x8f,0x0f};



 const PROGMEM  char TEST_code[]  = {
 
 0x3E,0x14,
 0x08,
 0x0E,0xD3,
 0x21,0x08,0x00,
 0xD3,0x01,
 0x00,
 0x08,
 0x3D,
 0x01,0x50,0xC3,
 0x18,0xE1,
 0xE3,
 0xE3,
 0xED,0xA1,
 0xE0,
 0x18,0xF9
 0x00,0x00,
 0x00,0x00,
 0x00,0x00,
 0x76
 
 };



  

    int d = 5;
    char name;
    
    char* parray;
    
    char buf[64];
    
    char* addr;

    char myChar;
    
    int j=0;
    int k;

//------------------------------------------------------------------------------   
  
void setup()
{
    Serial.begin(115200);

// Set up the various port lines for the ROMulator

// Data bus
  pinMode(2, OUTPUT);
  pinMode(3, OUTPUT);
  pinMode(4, OUTPUT);
  pinMode(5, OUTPUT);
  pinMode(6, OUTPUT);
  pinMode(7, OUTPUT);
  pinMode(8, OUTPUT);
  pinMode(9, OUTPUT);
  pinMode(10, OUTPUT);
  
// Bus control

    pinMode(MREQ,OUTPUT);
    pinMode(READ,OUTPUT);
    pinMode(WRITE,OUTPUT);
    pinMode(TRISTATE,OUTPUT);
    pinMode(IORQ,OUTPUT);
    pinMode(RESET,OUTPUT);
    
    digitalWrite(MREQ,HIGH); 
    digitalWrite(IORQ,HIGH); 
    digitalWrite(RESET,LOW);      // Hold the Z80 in RESET
    
// Shift register control
    pinMode(loadPin, OUTPUT);          // Set up the pins needed for the shift registers
    pinMode(sclkPin, OUTPUT);
//    pinMode(sinPin, INPUT);
    pinMode(latchPin, OUTPUT);
    pinMode(clockPin, OUTPUT);
    pinMode(dataPin, OUTPUT);
    digitalWrite(sclkPin,HIGH);    // initialise the clock HIGH


      x = 170;  // Test data - alternate 1's and 0's 

      if(x>=128){digitalWrite(10,HIGH); x =  x- 128;} else {digitalWrite(10,LOW);}
      if(x>=64){digitalWrite(9,HIGH); x =  x- 64;} else {digitalWrite(9,LOW);}
      if(x>=32){digitalWrite(7,HIGH); x =  x- 32;} else {digitalWrite(7,LOW);}
      if(x>=16){digitalWrite(6,HIGH); x =  x- 16;} else {digitalWrite(6,LOW);}
      if(x>=8){digitalWrite(5,HIGH); x =  x- 8;} else {digitalWrite(5,LOW);}
      if(x>=4){digitalWrite(4,HIGH); x =  x- 4;} else {digitalWrite(4,LOW);}
      if(x>=2){digitalWrite(3,HIGH); x =  x- 2;} else {digitalWrite(3,LOW);}
      if(x>=1){digitalWrite(2,HIGH); x =  x- 1;} else {digitalWrite(2,LOW);}





  digitalWrite(READ,HIGH);
  digitalWrite(WRITE,HIGH);
  digitalWrite(MREQ,HIGH);


    Serial.println("Use the w command to load the ROM image");

/*
  // read back a char
  int len = 255;
  for (k = 0; k < len; k++)
  {
    x =  pgm_read_byte_near(ROM_code+k);
    Serial.println(x);
  }
  Serial.println();
*/

    
    
    parray = &array[0][0];                // parray is the pointer to the first element 

    
}

// -----------------------------------------------------------------------------------------------------

void loop()             // The SIMPL interpreter is just the following 3 functions executed within a loop
{

  txtRead(buf, 64);      // Get the next character from the buffer
  txtChk(buf);           // check if it is a colon definition 
  txtEval(buf);          // Evaluate the character and execute the code associated with it
}

void txtRead (char *p, byte n) {
  byte i = 0;
  while (i < (n-1)) {
    while (!Serial.available());
    char ch = Serial.read();
    if (ch == '\r' || ch == '\n') break;
    if (ch >= ' ' && ch <= '~') {
      *p++ = ch;
      i++;
    }
  }
  *p = 0;
}


void txtChk (char *buf) {       // Check if the text starts with a colon and if so store in temp[]
 
  if (*buf == ':')  {  
  char ch;
  int i =0;
  while ((ch = *buf++)){
    
  if (ch == ':') {
  Serial.println(*buf);   // get the name from the first character
  name = *buf ;
  buf++;
  }
 
  bufWrite((parray + (len*(name-65) +i)),*buf);
   
  i++;

}

}

}
  
  void txtEval (char *buf) {
  unsigned int k = 0;

  char *loop;
  char ch;
  while ((ch = *buf++)) {
    

    switch (ch) {
    case '0':                  // Ennumerate it to a variable x if the characters are digits
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      x = ch - '0';
      while (*buf >= '0' && *buf <= '9') {
        x = x*10 + (*buf++ - '0');
      }
      break;
      
    case 'p':                        // Print out the value of x
      Serial.println(x);
      break;
      
      case '=':                    // more familiar for maths
      Serial.println(x);
      break;

     case 'a':                    // put the 16-bit address on the bus and asser MREQ low
     
          
      // Set up the address  - write the 16 bits to the address registers

      PORTB &= ~_BV(0);
      shiftOut(dataPin, clockPin, MSBFIRST, x>>8);  // shift out the high bits: 
      shiftOut(dataPin, clockPin, MSBFIRST, x);  // shift out the low bits:   
      PORTB |= _BV(0);

      digitalWrite(MREQ, LOW);

      break;

      
    case 'd':                // put 8-bit data on the bus and assert write and tristate


     // Make D2 to D9 OUTPUTS

     digitalWrite(WRITE, LOW);
     digitalWrite(TRISTATE,LOW);
      
    pinMode(2, OUTPUT);
    pinMode(3, OUTPUT);
    pinMode(4, OUTPUT);
    pinMode(5, OUTPUT);
    pinMode(6, OUTPUT);
    pinMode(7, OUTPUT);
    pinMode(8, OUTPUT);
    pinMode(9, OUTPUT);
    pinMode(10, OUTPUT);    
      
      if(x>=128){digitalWrite(10,HIGH); x =  x- 128;} else {digitalWrite(10,LOW);}
      if(x>=64){digitalWrite(9,HIGH); x =  x- 64;} else {digitalWrite(9,LOW);}
      if(x>=32){digitalWrite(7,HIGH); x =  x- 32;} else {digitalWrite(7,LOW);}
      if(x>=16){digitalWrite(6,HIGH); x =  x- 16;} else {digitalWrite(6,LOW);}
      if(x>=8){digitalWrite(5,HIGH); x =  x- 8;} else {digitalWrite(5,LOW);}
      if(x>=4){digitalWrite(4,HIGH); x =  x- 4;} else {digitalWrite(4,LOW);}
      if(x>=2){digitalWrite(3,HIGH); x =  x- 2;} else {digitalWrite(3,LOW);}
      if(x>=1){digitalWrite(2,HIGH); x =  x- 1;} else {digitalWrite(2,LOW);}
      
      break;
      
 
      
      
      
      case 'A':            // Point the interpreter to the array containing the words
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
          
      name = ch - 65;
      addr = parray + (len*name);      
      txtEval(addr);
      break;


      case ' ':

      y = x;
      
      case 'y':
      y = x;

 
      case '!':     // store
      y = x;
      break;
      
      case '@':     // fetch
      x = y;
      break;
      
      case '+':     // Add
      x = x+y;
      break;
      
      case '-':     // Subtract
      x = y-x;
      break;
      
      case '*':     // Multiply
      x = x*y;
      break;
      
      case '/':    // Divide 
      x = y/x;
      break;
      
      
      case '?':                             // Print out all the RAM
      parray = &array[0][0];                // reset parray to the pointer to the first element 
      
      for (int j = 0; j<26; j++) {      
      Serial.write(j+65);                  // print the caps word name
      Serial.write(20);                    // space   
      for (int i=0; i<len; i++) {
      bite = bufRead( parray +  (j *len )+i);          // read the array
      Serial.write(bite);                           // print the character to the serial port
    }
     Serial.println();
    
   }
      
   for(int i = 0; i <11; i++) {                 // Print 12 free lines so it looks better on Arduino serial screen
   Serial.println();
   
    }      
    break;
      
      
    case 'i':
      x = digitalRead(d);
      break;
    case 'o':
      digitalWrite(d, x%2);
      break;
    case 'm':
      delay(x);
      break;
    case 'u':
      delayMicroseconds(x);
      break;
    case '{':
      k = x;
      loop = buf;
      while ((ch = *buf++) && ch != '}') {
      }
    case '}':
      if (k) {
        k--;
        buf = loop;
      }
      break;
    case 'k':
      x = k;
      break;
    case '_':
      while ((ch = *buf++) && ch != '_') {
        Serial.print(ch);
      }
      Serial.println();
      break;
    case 's':
      x = analogRead(x);
      break;
      
      case 'q':            // Send an 16 bit to the shift registers using shiftOut
      
      // Set up the address  - write the 16 bits to the address registers

      PORTB &= ~_BV(0);
      shiftOut(dataPin, clockPin, MSBFIRST, x>>8);  // shift out the high bits: 
      shiftOut(dataPin, clockPin, MSBFIRST, x);  // shift out the low bits:   
      PORTB |= _BV(0);


        case 'n':                  
        
        // Output an 8 bit value on I/O Dig 2  - Dig 9
        // Can be extended to 12 bits on Dig 2 - Dig 13


      // Make D2 to D9 OUTPUTS

      
    pinMode(2, OUTPUT);
    pinMode(3, OUTPUT);
    pinMode(4, OUTPUT);
    pinMode(5, OUTPUT);
    pinMode(6, OUTPUT);
    pinMode(7, OUTPUT);
    pinMode(8, OUTPUT);
    pinMode(9, OUTPUT);
    pinMode(10, OUTPUT);    
      
      if(x>=128){digitalWrite(10,HIGH); x =  x- 128;} else {digitalWrite(10,LOW);}
      if(x>=64){digitalWrite(9,HIGH); x =  x- 64;} else {digitalWrite(9,LOW);}
      if(x>=32){digitalWrite(7,HIGH); x =  x- 32;} else {digitalWrite(7,LOW);}
      if(x>=16){digitalWrite(6,HIGH); x =  x- 16;} else {digitalWrite(6,LOW);}
      if(x>=8){digitalWrite(5,HIGH); x =  x- 8;} else {digitalWrite(5,LOW);}
      if(x>=4){digitalWrite(4,HIGH); x =  x- 4;} else {digitalWrite(4,LOW);}
      if(x>=2){digitalWrite(3,HIGH); x =  x- 2;} else {digitalWrite(3,LOW);}
      if(x>=1){digitalWrite(2,HIGH); x =  x- 1;} else {digitalWrite(2,LOW);}
      
      break;
 //-------------------------------------------------------------------------------------------     
      
      case 'r':            // read the value at the data port D2 - D10

      read_RAM(x);


      break;
/*      
      // Set up the address  - write the 16 bits to the address registers
      PORTB &= ~_BV(0);
      shiftOut(dataPin, clockPin, MSBFIRST, x>>8);  // shift out the high bits: 
      shiftOut(dataPin, clockPin, MSBFIRST, x);  // shift out the low bits:   
      PORTB |= _BV(0);
  
      pinMode(2, INPUT) ;
      pinMode(3, INPUT);
      pinMode(4, INPUT);
      pinMode(5, INPUT);
      pinMode(6, INPUT);
      pinMode(7, INPUT);
      pinMode(9, INPUT);
      pinMode(10, INPUT);
      // Assert MREQ
      digitalWrite(MREQ, LOW);
      // Take the buffer out of tri-state
     digitalWrite(TRISTATE,LOW);
      // Assert READ
      digitalWrite(READ, LOW);
    //  Get the data
    x = 0;
    if (digitalRead(2)){ x =  x+1;}
    if (digitalRead(3)){ x =  x+2;}
    if (digitalRead(4)){ x =  x+4;}
    if (digitalRead(5)){ x =  x+8;}
    if (digitalRead(6)){ x =  x+16;}
    if (digitalRead(7)){ x =  x+32;}
    if (digitalRead(9)){ x =  x+64;}
    if (digitalRead(10)){ x =  x+128;} 
//   delay(100);
 
      digitalWrite(READ, HIGH);
      digitalWrite(MREQ, HIGH);     // Deselect the RAM
      digitalWrite(TRISTATE,HIGH);    // Put the buffer into tri-state
      Serial.println(x);
      
      break;
*/      

//----------------------------------------------------------------------
      
      
      
      
      // Send an 16 bit byte to the shift register using shiftOut

  case 'w':

  digitalWrite(RESET, LOW);       // Put the Z80 into RESET

  
 for (k = 0; k < 32; k++)
  {
    x =  pgm_read_byte_near(TEST_code+k);
 
 
  write_RAM(x,k);
      
}

 Serial.println("RAM loaded!  Type z to run");

 break;




  case 'z':

// Take the Z80 out of Reset


digitalWrite(RESET, HIGH);

break;


  case 'l':       // list the Rom file in the RAM

  Serial.println("Resetting the Z80");

  digitalWrite(RESET, LOW);


   for (j=0; j<x; j++)
      {    
        read_RAM(j);
        Serial.print(" ");
        if(j%16==0)
        {
          Serial.println();
        }
     }
      

      break;





/*
  
// Write Cycle
// Connect DIR to /WR as a write cycle is from B to A and a read is from A to B
// Set up the address  - write the 16 bits to the address registers
      PORTB &= ~_BV(0);
      shiftOut(dataPin, clockPin, MSBFIRST, x>>8);  // shift out the high bits: 
      shiftOut(dataPin, clockPin, MSBFIRST, x);  // shift out the low bits:   
      PORTB |= _BV(0);
     
      x = y;        // get the data byte
      // Assert WRITE   - sets the direction of the bi-directional buffer
      digitalWrite(WRITE, LOW);
     // Take the buffer out of tri-state
     digitalWrite(TRISTATE,LOW);
// Set up the data  - output the 8 bits D0-D7 on Digital pins D2-D9
    pinMode(2, OUTPUT);
    pinMode(3, OUTPUT);
    pinMode(4, OUTPUT);
    pinMode(5, OUTPUT);
    pinMode(6, OUTPUT);
    pinMode(7, OUTPUT);
    pinMode(8, OUTPUT);
    pinMode(9, OUTPUT);
    pinMode(10, OUTPUT);    
      if(x>=128){digitalWrite(10,HIGH); x =  x- 128;} else {digitalWrite(10,LOW);}
      if(x>=64){digitalWrite(9,HIGH); x =  x- 64;} else {digitalWrite(9,LOW);}
      if(x>=32){digitalWrite(7,HIGH); x =  x- 32;} else {digitalWrite(7,LOW);}
      if(x>=16){digitalWrite(6,HIGH); x =  x- 16;} else {digitalWrite(6,LOW);}
      if(x>=8){digitalWrite(5,HIGH); x =  x- 8;} else {digitalWrite(5,LOW);}
      if(x>=4){digitalWrite(4,HIGH); x =  x- 4;} else {digitalWrite(4,LOW);}
      if(x>=2){digitalWrite(3,HIGH); x =  x- 2;} else {digitalWrite(3,LOW);}
      if(x>=1){digitalWrite(2,HIGH); x =  x- 1;} else {digitalWrite(2,LOW);}
// Select the RAM
 // Assert MREQ
  digitalWrite(MREQ, LOW);
   
     
    //  Send the data
//    delay(100);
// Assert /WR
// Deselct RAM
digitalWrite(MREQ,HIGH);
// De-assert /WR
digitalWrite(WRITE, HIGH);
 // Put the buffer into tri-state
     digitalWrite(TRISTATE,HIGH);
break;
// Tristate registers and data buffer
// Read Cycle
// Set up the address
// Set up the data 
// Select the RAM
// Assert /RD
// Read the data from the port into memory
// De-assert /RD
// Deselct RAM
// Tristate registers and data buffer
      
      
//      PORTB &= ~_BV(0);
//      shiftOut(dataPin, clockPin, MSBFIRST, x>>8);  // shift out the high bits: 
//      shiftOut(dataPin, clockPin, MSBFIRST, x);  // shift out the low bits:   
//      PORTB |= _BV(0);
//      break;
      
      case 't':     // test the inputs from 74HC165 shift registers
     
     // Read incoming word from 74HC165
      digitalWrite(loadPin, LOW);
      digitalWrite(loadPin, HIGH);
      x = shiftIn(sinPin, sclkPin, MSBFIRST);  
      digitalWrite(sclkPin,HIGH); 
      
      break;
    
  */    
      
      
    }
  }
}



void read_RAM( int address)

{


  // Set up the address  - write the 16 bits to the address registers

      PORTB &= ~_BV(0);
      shiftOut(dataPin, clockPin, MSBFIRST, x>>8);  // shift out the high bits: 
      shiftOut(dataPin, clockPin, MSBFIRST, x);  // shift out the low bits:   
      PORTB |= _BV(0);
  

      pinMode(2, INPUT) ;
      pinMode(3, INPUT);
      pinMode(4, INPUT);
      pinMode(5, INPUT);
      pinMode(6, INPUT);
      pinMode(7, INPUT);
      pinMode(9, INPUT);
      pinMode(10, INPUT);

      digitalWrite(MREQ, LOW);           // Assert MREQ
      digitalWrite(TRISTATE,LOW);        // Take the buffer out of tri-state
      digitalWrite(READ, LOW);           // Assert READ

    //  Get the data

    x = 0;

    if (digitalRead(2)){ x =  x+1;}
    if (digitalRead(3)){ x =  x+2;}
    if (digitalRead(4)){ x =  x+4;}
    if (digitalRead(5)){ x =  x+8;}
    if (digitalRead(6)){ x =  x+16;}
    if (digitalRead(7)){ x =  x+32;}
    if (digitalRead(9)){ x =  x+64;}
    if (digitalRead(10)){ x =  x+128;} 

 
      digitalWrite(READ, HIGH);
      digitalWrite(MREQ, HIGH);     // Deselect the RAM
      digitalWrite(TRISTATE,HIGH);    // Put the buffer into tri-state

      Serial.print(x,HEX);
       
}




void write_RAM(int data,int address)

{

  // Write Cycle

// Connect DIR to /WR as a write cycle is from B to A and a read is from A to B


      x= address;

// Set up the address  - write the 16 bits to the address registers

      PORTB &= ~_BV(0);
      shiftOut(dataPin, clockPin, MSBFIRST, x>>8);  // shift out the high bits: 
      shiftOut(dataPin, clockPin, MSBFIRST, x);  // shift out the low bits:   
      PORTB |= _BV(0);
     


      x = data;        // get the data byte

      // Assert WRITE   - sets the direction of the bi-directional buffer

      digitalWrite(WRITE, LOW);

     // Take the buffer out of tri-state

     digitalWrite(TRISTATE,LOW);


// Set up the data  - output the 8 bits D0-D7 on Digital pins D2-D9

    pinMode(2, OUTPUT);
    pinMode(3, OUTPUT);
    pinMode(4, OUTPUT);
    pinMode(5, OUTPUT);
    pinMode(6, OUTPUT);
    pinMode(7, OUTPUT);
    pinMode(8, OUTPUT);
    pinMode(9, OUTPUT);
    pinMode(10, OUTPUT);    


      if(x>=128){digitalWrite(10,HIGH); x =  x- 128;} else {digitalWrite(10,LOW);}
      if(x>=64){digitalWrite(9,HIGH); x =  x- 64;} else {digitalWrite(9,LOW);}
      if(x>=32){digitalWrite(7,HIGH); x =  x- 32;} else {digitalWrite(7,LOW);}
      if(x>=16){digitalWrite(6,HIGH); x =  x- 16;} else {digitalWrite(6,LOW);}
      if(x>=8){digitalWrite(5,HIGH); x =  x- 8;} else {digitalWrite(5,LOW);}
      if(x>=4){digitalWrite(4,HIGH); x =  x- 4;} else {digitalWrite(4,LOW);}
      if(x>=2){digitalWrite(3,HIGH); x =  x- 2;} else {digitalWrite(3,LOW);}
      if(x>=1){digitalWrite(2,HIGH); x =  x- 1;} else {digitalWrite(2,LOW);}


      // Select the RAM

      // Assert MREQ

      digitalWrite(MREQ, LOW);

      //  Send the data

      // Assert /WR

      // Deselct RAM
      digitalWrite(MREQ,HIGH);


      // De-assert /WR
      digitalWrite(WRITE, HIGH);


      // Put the buffer into tri-state
     digitalWrite(TRISTATE,HIGH);

}